# C++ 빌드
Visual Studio Code에서 C++ 프로젝트를 시작할 때 기본적으로 설정해야 할 것들  
1. 작업 공간 설정: 프로젝트 폴더 생성
2. 컴파일러 설치 및 설정: C++ 컴파일러(GCC, Clang, MSVC 등)를 설치하고, VSCode 내에서 사용할 수 있도록 환경 변수에 추가하거나 설정
3. C++ 확장 설치: VSCode 마켓플레이스에서 C++ 확장 프로그램을 설치
4. 빌드 및 디버그 설정: .vscode 폴더 내에 `launch.json`, `tasks.json` 파일을 통해 프로젝트의 빌드 및 디버그 환경을 설정
5. main.cpp 실행: macOS나 리눅스에서는 ./파일명 형태로, Windows에선 파일명.exe 형태로 터미널에서 실행 가능

### json 파일 조금 더 살펴보기
- `tasks.json`: 빌드 과정을 정의하는 파일이며, 컴파일러 호출 방법, 컴파일에 필요한 인자, 빌드 명령어 등을 지정할 수 있습니다.
```
tasks.json

type: 작업의 유형 지정
label: 작업을 식별하기 위한 사용자 정의 이름 지정
command: 빌드 작업을 실행할 컴파일러 명령어나 스크립트 지정
args: command에 전달할 인자 목록으로, 컴파일러 옵션과 대상 파일을 설정
options: 작업을 실행할 때의 추가 옵션을 설정
problemMatcher: 컴파일 과정 중 발생하는 문제를 VSCode가 어떻게 감지하고 보여줄지 설정
group: 작업을 그룹화하고, 이 작업이 빌드 작업의 기본값으로 사용될지 여부를 결정
detail: 작업에 대한 추가 설명을 제공

```
- `launch.json`: 디버거 설정을 정의하는 파일이며, 실행 파일의 경로, 디버그할 때 필요한 인자, 환경 변수 등을 설정할 수 있습니다.
```
launch.json

type: 디버거 타입을 지정
request: 디버깅 세션의 종류를 지정
name: 디버그 구성의 이름을 지정
program: 디버깅할 실행 파일의 경로를 지정
args: 프로그램을 실행할 때 전달할 인자들을 배열 형태로 지정
cwd: 프로그램의 현재 작업 디렉토리를 지정
enviroment: 프로그램 실행 시 사용할 환경 변수를 배열로 지정
preLaunchTask: 디버깅을 시작하기 전에 실행할 빌드 작업의 레이블을 지정
```

# 이야기의 시작
Cppia는 C++ 빌드 시스템의 세계로 모험을 떠나는 호기심 많고 열정적인 개발자입니다. Cppia는 프로그래밍의 기본부터 배우고 싶었고, 그 여정의 첫걸음으로 빌드 시스템을 이해하고자 합니다.
## 빌드 시스템 소개
#### 빌드란 무엇인가?
빌드란, 소스 코드를 컴퓨터에서 실행 가능한 프로그램이나 소프트웨어로 변환하는 과정입니다.
#### 빌드 과정의 중요성
Cppia는 코드의 작은 변경 사항이라도 최종 프로그램에 올바르게 반영되려면, 빌드 과정이 효율적이고 정확해야 하기 때문에 빌드의 중요성을 단번에 알아차렸습니다. 어떤 것이든 체계적인 시스템이 구축되어 있지 않으면 집중력이 분산되기 마련이니까요.
## 컴파일 과정 이해
빌드의 이해는 컴파일 과정의 이해로 이어지고 있었습니다. 
#### 컴파일이란 무엇인가?
Cippia는 컴파일러라는 마법사이자 조력자를 만납니다. Cppia가 작성한 소스 코드는 컴파일러라는 마법사에 의해 기계어로 변환되는데, 이 과정을 컴파일이라고 합니다. 소스 코드는 단순한 텍스트 파일, 기계어는 컴퓨터가 이해할 수 있는 언어로 컴파일러가 이 두 세계를 연결시켜주는 다리의 역할을 합니다.
## 컴파일러 소개
#### 대표적인 C++ 컴파일러
각 마법사는 독특한 힘과 특성을 가지고 있습니다.
- GCC(GNU Compiler Collection): 강력하고 다재다능한 마법사로, 여러 언어의 주문을 다룰 수 있습니다.
- Clang: 빠르고 현대적인 마법사로, 명확하고 유용한 마법 주문과 오류 메세지를 제공합니다.
- MSVC(Microsoft Visual C++): 윈도우즈 왕국에서 강력한 힘을 발휘하는 마법사입니다.
#### 컴파일러 선택 기준
- 주문의 종류(프로그래밍 언어): 프로젝트에 맞는 언어를 지원하는 마법사를 선택합니다.
- 마법의 힘(컴파일러의 성능과 최적화): 빌드 속도와 실행 파일의 효율성을 확인합니다.
- 마법 주문의 호환성(플랫폼 지원): 타겟 플랫폼에 맞는 컴파일러를 선택합니다.
- 마법의 도구(개발 환경과 도구 지원): IDE나 디버깅 도구와의 통합을 확인합니다.
## 컴파일러 옵션과 최적화
Cppia는 마법의 세계를 더 깊이 탐험하기 위해 마법사 컴파일러의 옵션과 주문(코드)의 효과를 최적화 하는 방법을 배워야했습니다.
#### 기본 컴파일러 옵션과 최적화 옵션
각 마법사는 주문을 강화하고 맞춤화하기 위한 다양한 옵션을 제공합니다.
- 경고 옵션: -Wall, -Wextra (추가 경고 활성화), -Werror (모든 경고를 에러로 취급)
- 최적화 옵션: -00 (최적화 없음), -01, -02, -03 (점점 더 강력한 최적화), -0s (크기 최적화), -0fast (최대 속도 최적화)
- 디버깅 옵션: -g (디버깅 정보 추가), -ggdb (GDB 디버거에 특화된 정보 추가)
- 언어 표준 옵션: -std=c++11, -std=c++14, -std=c++17, -std=c++20 (C++ 표준 버전 선택)

### 예시
```
GCC 마법사

g++ -Wall -02 main.cpp -o main

// -Wall: 모든 경고 메세지를 활성화
// -02: 일반적인 최적화를 활성화해 성능을 향상시키지만, 컴파일 시간이 길어질 수 있다.
```

```
Clang 마법사

clang++ -Weverything -03 main.cpp -o main

// -Weverything: 가능한 모든 경고를 활성화
// -03: 더 공격적인 최적화를 수행해 실행 파일의 성능을 극대화하지만, 리스크가 있을 수 있다.
```

```
MSVC 마법사

cl /W4 /02 main.cpp /Fe:main.exe

// /W4: 거의 모든 경고 메세지를 표시
// /02: 속도 최적화를 위해 사용
```

Cppia는 이 옵션들을 사용해 주문을 더 강력하고 효율적으로 만들어 모험을 한결 수월하게 진행할 수 있게 되었습니다.
## 링킹 이해하기
Cppia는 두 갈래 길에 도달합니다: 정적 마법의 숲과 동적 마법의 도시. 정적 마법의 숲은 모든 마법의 재료를 가지고 다니며, 필요할 때마다 즉시 마법을 사용할 수 있는 곳입니다. 반면, 동적 마법의 도시는 마법의 재료를 공유하는 큰 도서관이 있어, 필요할 때마다 재료를 빌려 마법을 시전할 수 있습니다.
#### 정적 링킹 vs. 동적 링킹
- 정적 링킹: 컴파일 시간에 모든 필요한 라이브러리 코드를 최종 실행 파일에 직접 포함시키는 방식으로, 파일 크기가 커지지만 별도의 라이브러리가 필요하지 않으므로 배포와 실행이 간편해집니다.
- 동적 링킹: 실행 시간에 필요한 라이브러리를 로드하여 사용하는 방식으로, 실행 파일 크기가 작아지고, 라이브러리를 공유할 수 있어 메모리 사용이 효율적입니다. 그러나 해당 라이브러리가 시스템에 설치되어 있어야 하며 버전 호환성을 고려해야합니다.
## 빌드 자동화 도구
#### Make와 Makefile
#### CMake: 크로스 플랫폼 빌드 시스템
#### 기타 도구(Bazel, Ninja 등)
## 크로스 컴파일링
#### 크로스 컴파일링의 개념
#### 다른 플랫폼을 위한 빌드 설정
## 디버깅과 프로파일링
#### 디버깅 기법
#### 성능 분석을 위한 프로파일링 도구
## 테스팅 전략
#### 단위 테스트
#### 통합 테스트
## CI/CD 파이프라인과 빌드 자동화
#### Continuous Integration/Continuous Deployment
#### CI/CD 도구와의 통합(Github Actions, GitLab CI 등)