# 운영체제
## 운영체제란
모든 프로그램은 실행을 위해 **자원**(resource)을 필요로 한다. 여기에 컴퓨터의 네 가지 핵심 부품이 포함된다. **운영체제**는 이러한 필요 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이다.  

프로그램은 메모리에 적재되어 실행된다. 운영체제는 프로그램 중 가장 핵심적이기 때문에 다른 응용 프로그램과 달리 메모리 내 **커널 영역**이라는 곳에 적재된다. 다른 응용 프로그램은 **사용자 영역**이라는 곳에 적재된다.  

우리는 인터넷 브라우저를 실행할 때 메모리의 xx번지를 실행하라는 식으로 지시를 내리지 않았다. 그 역할을 운영체제가 해주고 있었다. 이게 운영체제의 **메모리 관리** 기능이다.

또, 우리는 인터넷만 하지 않는다. 음악도 듣고, 메모장도 사용할 수 있다. CPU가 이 많은 것들을 동시에 처리한다고 보이지만, 사실 눈치 못챌만큼 빠르게 번갈아가면서 실행시키고 있다고 볼 수 있다. 이 여러 프로그램 중 우선순위를 부여하거나 CPU 할당을 다르게 하는 것도 운영체제가 하는 **CPU 관리** 기능이다.  

워드와 메모장, 두 곳에서 프린터 출력을 하고 싶을 때 순서를 정하는 것도 운영체제의 **입출력장치 관리** 기능이다.  

즉, 운영체제는 하드웨어와 응용 프로그램 사이에 위치해서 자원을 효율적으로 분배하는 관리자 역할을 한다. 이는 국민을 위해 나라의 자원을 효율적으로 관리/분배해주는 정부의 역할과 유사하다.

## 운영체제를 왜 알아야하는가?
운영체제는 사용자를 위한 프로그램이 아닌, 프로그램을 위한 프로그램이다. 그렇기에 프로그램을 만드는 개발자는 운영체제를 알아야한다. 오류 메세지의 주체는 운영체제인 경우가 많아, 운영체제에 대한 이해는 오류 메세지에 대한 이해가 되고 문제 해결 능력의 향상을 가져온다.

## 운영체제의 큰 그림
#### 커널
운영체제는 현존하는 프로그램 중 규모가 가장 큰 프로그램 중 하나다. Windows, MacOS, Linux 등과 같이 다양한 운영체제가 있고, 따라서 운영체제가 제공하는 기능도 다양하다. 하지만, 그 중 공통적이고 핵심적인 기능은 존재한다. 자원에 접근하고 조작하는 기능, 프로그램이 올바르게 실행되도록 하는 기능이 그것인데, 이걸 담당하는 부분을 **커널**이라고 한다.  

> 운영체제에는 속하는데 커널에는 속하지 않는 기능이 있나?   

대표적으로, 유저 인터페이스(UI)가 있다.

#### 이중모드와 시스템 콜(호출)
일반적으로 응용 프로그램이 자원에 직접 접근하는 게 안전할까? 대답은 No다. 따라서 운영체제는 응용 프로그램이 자원에 접근하려 할 때, 오직 자신을 통해서만 접근하도록 제한을 두어 자원을 보호한다. 이런 문지기 역할은 **이중모드**를 통해 달성된다. 이중모드는 크게 두 가지로 구분한다.

1. **사용자 모드**: 운영체제 서비스를 제공받을 수 없는 실행 모드다. 커널 영역의 코드를 실행할 수 없고, 자원에 접근이 불가능하다.
2. **커널 모드**: 운영체제의 서비스를 제공받을 수 있는 실행 모드로 자원 접근을 비롯한 모든 명령어 실행이 가능한 모드다.

플래그 레지스터 속 슈퍼바이저 플래그를 통해 커널 모드인지, 사용자 모드인지 CPU가 알 수 있다.

> 그럼 언제 커널 모드로 전환되는거지?

**시스템 호출**을 통해서 커널 모드로 전환이 된다. 시스템 호출도 일종의 소프트웨어 인터럽트이다.

#### 운영체제의 핵심 서비스
- **프로세스 관리**: 프로세스는 실행 중인 프로그램을 말하고, 일반적으로 동시에 여러 프로세스를 실행한다. 이런 수많은 프로세스들의 생성/실행/삭제를 일목요연하게 관리하는 역할을 담당한다.
- **자원 접근 및 할당**: 어떤 프로세스를 먼저, 얼마나 오래 실행한지를 결정하는 *CPU 스케줄링*과 *페이징*, *스와핑* 같은 메모리 관련 기능을 수행한다.
- **파일 시스템 관리**: 관련된 정보를 *파일*이라는 단위로 묶어 저장 장치에 보관하고, 그 파일들을 묶어 *폴더(디렉토리)* 단위로 저장 장치에 보관하는 역할을 한다.

## 프로세스 개요
- **Foreground process**: 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- **Background process**: 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    - 사용자와 직접 상호작용이 가능한 백그라운드 프로세스: 예시로 데몬과 서비스가 있다.
    - 사용자와 상호작용 없이 정해진 일만 수행하는 프로세스

#### 프로세스 제어 블록
모든 프로세스는 실행을 위해 CPU가 필요하다. 하지만 CPU 자원은 한정되어 있다. 따라서 프로세스들은 돌아가며 한정된 시간 만큼만 CPU를 이용한다. 이를 위해 사용하는 자료 구조를 **프로세스 제어 블록**(PCB)이다. 상품에 달린 태그처럼 프로세스 관련 정보를 저장하고 있고, 프로세스 생성 시 커널 영역에 생성됐다가 종료 시 폐기된다.

> 어떤 정보가 담길까?
- **프로세스 ID**(PID)
- **레지스터 값**: 프로세스는 자신의 실행 차례가 오면 이전까지 사용한 레지스터 값을 복원하여 실행을 재개하기 때문에 필요하다.
- **프로세스 상태**
- **CPU 스케줄링 정보**
- **메모리 정보**: 프로세스가 어느 주소에 저장되어 있는지에 대한 정보, 페이지 테이블 정보가 담긴다.
- **사용한 파일과 입출력장치 정보**

#### 문맥 교환(context switch)
> 한 프로세스A에서 다른 프로세스B로 실행 순서가 넘어가면?

기존에 실행되던 프로세스 A는 지금까지의 중간 정보를 백업시키고, 뒤이어 실행할 프로세스 B의 문맥을 복구한다.

#### 프로세스의 메모리 영역
사용자 영역은 크게 네 가지로 아래와 같다.
- **코드 영역**(텍스트 영역): 데이터가 아닌 CPU가 실행할 명령어가 담겨있어 쓰기가 불가능한 read-only 영역이다.
- **데이터 영역**: 잠깐 썼다가 지울 데이터가 아닌, 프로그램 실행동안 유지할 데이터를 저장하느 영역이다. 예를 들어, 전역 변수가 여기에 해당한다.
- **힙 영역**: 프로그래머가 직접 할당할 수 있는 저장공간이다. 이 메모리 공간은 나중에 꼭 반환을 시켜야하는데, 요즘 언어는 *가비지 컬렉션*이라는 기능을 통해 자동으로 수행하기도 한다. 반환이 안된다면 힙 영역이 계속 메모리 공간을 차지함으로써 메모리의 낭비를 초래하는 *메모리 누수*가 일어난다.
- **스택 영역**: 데이터가 일시적으로 저장되는 공간이다. 예를 들어, 매개 변수, 지역 변수가 여기에 해당한다.

프로세스 실행 중 영역의 크기가 가변적으로 변하는지 여부에 따라서 코드 영역/데이터 영역을 **정적 할당 영역**, 힙 영역/스택 영역을 **동적 할당 영역**이라고 하기도 한다.

### 프로세스 상태와 계층 구조
#### 프로세스 상태
- 생성 상태: 이제 막 메모리에 적재되어 PCB를 할당 받은 상태를 말한다.
- 준비 상태: 당장이라도 CPU를 할당 받아 실행할 수 있지만, 자신의 차례를 기다리는 상태를 말한다.
- 실행 상태: CPU를 할당 받아 실행 중인 상태를 말한다. 타이머 인터럽트가 발생하면 준비 상태로 돌아간다.
- 대기 상태: 프로세스가 실행 도중 입출력장치를 사용할 경우 대기 상태에 접어든다. 대기 상태에서 입출력장치의 사용이 완료되면 준비 상태로 돌아간다.
- 종료 상태: 프로세스가 종료된 상태로, PCB를 폐기하고 메모리 영역을 정리한다.

#### 프로세스 계층 구조
프로세스 실행 도중 시스템 호출을 통해 다른 프로세스 생성이 가능한데, 새 프로세스를 생성한 프로세스를 **부모 프로세스**라고 하고, 부모 프로세스에 의해 생성된 프로세스를 **자식 프로세스**라고 한다. 이 두 프로세스는 각기 다른 프로세스이기 때문에 서로 다른 PID를 갖는다. 자식 프로세스는 또 다른 자식 프로세스를 생성할 수 있고, 이렇게 계층적 구조가 만들어진다.

> 부모 프로세스는 어떻게 자식 프로세스를 만들고, 자식 프로세스는 자신의 코드를 어떻게 실행할까?

윈도우즈를 제외한 다양한 운영체제에서 *복제*와 *옷 갈아입기*를 통해 자식 프로세스가 생성되고, 자식 프로세스는 자신만의 코드를 실행할 수 있다.  
- *복제*: 부모 프로세스는 **fork** 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성한다.
- *옷 갈아입기*: 자식 프로세스는 **exec** 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 덮어쓴다.

### 스레드
스레드는 프로세스를 구성하는 **실행 흐름의 단위**로, 하나의 프로세스는 하나 이상의 스레드를 가질 수 있다. 이는 하나의 스레드에 스레드 ID, 프로그램 카운터를 비롯한 레지스터 값, 스택 등 실행에 필요한 최소한의 정보가 담겨있기 때문에 가능한 것이다.  

> 그럼 멀티 프로세스와 멀티 스레드는 무엇이 다른걸까?

이는 동일한 작업을 수행하는 단일 스레드 여러 개를 실행하는 것과 하나의 프로세스를 여러 스레드로 실행하는 것의 차이를 보겠다는 말이다. 전자는 위에서 fork로 복제한 새로운 프로세스를 여러 개 만드는 것과 같고, 이 프로세스들은 서로 자원을 공유하지 않고 독립적으로 실행된다. 반면, 후자는 자원을 공유해서 협력과 통신에 유리하다.  

> 프로세스끼리는 자원 공유가 불가능한가?

프로세스끼리 자원을 주고 받을 수 있는 *프로세스 간 통신*(Interprocess Communication; IPC)이 있다. 여기엔 파일을 통한 IPC, 공유 메모리를 통한 IPC가 있다.

## CPU 스케줄링 개요
**CPU 스케줄링**은 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는걸 말한다. 여기서 말하는 공정함은 선착순일까? 프로세스 간 우선순위의 차이가 있어서 선착순은 부족하다. 예를 들어, 입출력 작업이 많은 프로세스의 우선순위는 CPU 작업이 많은 프로세스의 우선순위보다 높다. 입출력 작업은 잠깐 할애하고 나면 대기 상태에 접어들기 때문에 빨리 처리해버리고 CPU 작업에 몰빵하는 게 효율적이다.

#### 스케줄링 큐
여러 PCB이 각각 특정한 자원(메모리, CPU, 하드 디스크 등)을 사용하고 싶어할 때, 각 자원마다 줄을 세우는걸 **스케줄링 큐**라고 한다. 자료 구조에서의 큐와 다르게 꼭 FIFO(First In First Out)구조일 필요는 없다. 대표적인 종류는 아래와 같다.

- **준비 큐**: CPU를 이용하기 위해 기다리는 줄
- **대기 큐**: 입출력장치를 이용하기 위해 기다리는 줄

급하게 CPU를 사용할 일이 있는 경우를 위한 스케줄링은 아래와 같다.

- **선점형(preemptive) 스케줄링**: 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당하는 방법
- **비선점형(non-preemptive) 스케줄링**: 현재 CPU를 사용 중인 프로세스가 끝날 때까지 기다리는 방법

### 스케줄링 알고리즘
대표적인 알고리즘 7 가지는 아래와 같다.
1. **선입 선처리 스케줄링**(First Come First Served): 먼저 CPU를 요청한 프로세스부터 할당하는, 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링이다. 프로세스 실행 시간이 매우 길어질 수 있는 부작용이 존재한다(호위효과).
2. **최단 작업 우선 스케줄링**(Shortest Job First): CPU 사용 시간이 짧은 프로세스부터 먼저 처리하는 스케줄링 방식으로, 호위효과를 방지할 수 있다.
3. **라운드 로빈 스케줄링**(Round Robin): 선입 선처리 스케줄링과 타임 슬라이스가 더해진 스케줄링 방식이다. 타임 슬라이스는 각 프로세스가 CPU를 정해진 시간동안 사용하는 방식으로, 정해진 타임 슬라이스만큼의 시간을 돌아가며 CPU를 사용하는 선점형 스케줄링 방식이다.
4. **최소 잔여 시간 우선 스케줄링**(Shortest Remaining Time): 최단 작업 우선 스케줄링과 라운드 로빈 스케줄링을 더한 개념이다.
5. **우선순위 스케줄링**: 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 처리하는 방식이다. 우선순위가 같은 프로세스엔 선입 선처리 스케줄링 방식을 사용한다. 이 방식은 높은 우선순위의 프로세스만 실행시키고, 낮은 우선순위의 프로세스는 무기한 실행을 연기하는 *starvation* 문제가 있다. 이를 방지하기 위한 방법으로 *aging*이 있다. 오래 대기한 프로세스의 우선순위는 점차 증가시키는 방식이다.
6. **다단계 큐 스케줄링**(Multilevel queue): 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다. 프로세스 유형별로 정리가 가능하다는 장점이 있지만 큐 간 이동이 불가능해서 starvation 문제가 발생할 수 있다.
7. **다단계 피드백 큐 스케줄링**: 큐 간 이동을 가능하게 만든 multilevel queue 방식의 단점을 보완한 발전된 방식이다.

## 프로세스 동기화
동시다발적으로 실행되는 프로세스들은 서로 협력하며 영향을 주고 받는데, 이 과정에서 **자원의 일관성**이 보장돼야 한다. 여기서 동기화의 필요성이 나온다. 동기화란, 프로세스들의 수행 시기를 맞추는 것인데 크게는 아래와 같다.
- **실행 순서 제어**: 프로세스를 올바른 순서대로 실행하는 것
- **상호 배제**: 동시에 접근해선 안되는 자원에 하나의 프로세스만 접근할 수 있게 만드는 것

> 실행 순서 제어를 위한 동기화: reader writer problem

Writer는 book.txt에 값을 저장하는 프로세스, Reader는 book.txt에 저장된 값을 읽어들이는 프로세스이다. Reader는 book.txt 안에 값이 존재해야한다는 특정 조건에 부합해야만 실행될 수 있다. 이처럼 Reader와 Writer 프로세스는 실행 순서에 맞게 실행되어야 한다.  

> 상호 배제를 위한 동기화: back account problem

현재 계좌에 잔액 10만원이 있고, 프로세스 A는 현재 잔액에 2만원을 더하여 저장하고, 프로세스 B는 현재 잔액에 5만원을 더하여 저장한다고 하자. 만약, 프로세스 A와 B를 상호 배제 없이 동시에 실행하면 17만원이 찍힐까? 그렇지 않다.

> producer consumer problem

```
총합 = 10

생산자 () {
    버퍼에 데이터 삽입
    '총합' 변수 1 증가
}

소비자 () {
    버퍼에서 데이터 빼내기
    '총합' 변수 1 감소
}
```

위 상황에서 생산자 100,000번, 소비자 100,000번을 동시에 실행하면 총합은 그대로 10일까? 그렇지 않다.

#### 공유 자원과 임계 구역
- **공유 자원**: 여러 프로세스 혹은 스레드가 공유하는 자원을 말한다. 예시로, 전역 변수, 파일, 입출력장치, 보조기억장치 등이 있다.
- **임계 구역**: 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 말한다. 예시로, back account problem의 `잔액` 변수와 producer consumer problem의 `총합` 변수가 있다. 임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있는데 이 상황을 *race condition*이라고 한다.

> 운영체제가 임계 구역 문제를 해결하기 위해 어떤걸 할 수 있을까?

1. 상호 배제(mutual exclusion): 한 프로세스가 임계 구역에 들어왔다면 다른 프로세스는 들어올 수 없다.
2. 진행(progress): 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야한다.
3. 유한 대기(bounded waiting): 한 프로세스가 임계 구역에 진입하고 싶다면 언젠간 진입할 수 있어야한다.

### 프로세스 동기화 기법
가장 대표적인 세 가지를 알아보자.
1. **뮤텍스 락**: 상호 배제를 위한 동기화 도구로, 탈의실 하나(임계 구역)에 한 명(프로세스)이 들어가면 나올 때까지 밖에서 차례로 기다리는 걸 떠올릴 수 있다.
2. **세마포**: 상호 배제와 실행 순서 동기화가 가능하다. 세마포란 열차가 지나갈 때 통행을 금지시키는 신호등 역할의 시설물에서 유래했다. 공유 자원이 하나였던 뮤텍스 락에 비해 여러 개를 상정한 방법으로 뮤텍스 락보다 조금 더 일반화된 방식의 동기화 도구다. 종류로는 *이진 세마포*, *카운팅 세마포*가 있다. 
3. **모니터**: 프로그램이 커지면 wait 함수와 signal 함수의 순서를 헷갈릴 수 있는데, 그 문제를 해결하기 위한 방식이다. 상호 배제와 실행 순서 제어를 위한 동기화가 가능하다. 

#### 뮤텍스 락
```
lock = true

acquire () {
    while (lock == true) // 임계 구역이 잠겨 있다면
        ; // 임계 구역이 잠겨 있는지 계속해서 확인하고
    lock = true; // 잠겨 있지 않다면 임계 구역 잠금 
}

release () {
    lock = false; // 임계 구역 작업이 끝났으니 잠금을 해제
}

acqurie();
// 임계 구역 작업 진행
release();
```
> acquire 함수 내 while() ; 부분이 비효율적일거같은데?

마치 탈의실이 잠겼는지를 계속해서 확인해야하는 이 방식을 *busy waiting*이라고 한다. CPU의 사이클 낭비가 발생한다. 이는 사용할 수 있는 자원이 없을 경우 대기 상태를 만들거나 사용할 수 있는 자원이 있을 경우 대기 큐의 프로세스를 준비 상태로 전환시키는 방식을 통해 해결할 수 있다.

#### 세마포
```
상호 배제

S; // 공유 자원의 갯수

wait () {
    while (S <= 0) // 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
        ; // 사용할 수 있는 자원이 있는지 계속해서 확인하고
    S--; // 임계 구역에 진입할 수 있는 프로세스가 하나 이상이면 S를 1 감소시키고 임계 구역 진입
}

signal () {
    S++; // 임계 구역 작업이 끝났으면 S를 1 증가
}

wait();
// 임계 구역 작업 진행
signal();
```

```
실행 순서 제어

S = 0; // 세마포 변수 S를 0으로 둔다.

signal(); // 먼저 실행할 프로세스 뒤에 signal 함수를 붙인다.
//먼저 실행할 프로세스

wait(); // 다음에 실행할 프로세스 앞에 wait 함수를 붙인다.
//다음에 실행할 프로세스
```

#### 모니터
```
상호 배제

1. 인터페이스를 위한 큐를 따로 준비한다.
2. 공유 자원에 접근하고자 하는 프로세스를 인터페이스 큐에 삽입한다.
3. 큐에 삽입된 순서대로 하나의 프로세스씩 공유 자원을 이용한다.
```

```
실행 순서 제어

1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 땐 wait을 통해 실행을 중단한다.
2. 특정 프로세스가 실행될 조건이 충족되었을 땐 signal을 통해 실행을 재개한다.
```

### 교착 상태
교착 상태를 식사하는 철학자 문제를 통해 이해해보자. 원형의 테이블에 철학자(프로세스) 5명, 포크(자원) 5개가 있고 식사(실행)를 아래와 같은 규칙에 의해 한다.

1. 계속 생각을 하다가 왼쪽 포크가 사용 가능하면 집어든다.
2. 계속 생각을 하다가 오른쪽 포크가 사용 가능하면 집어든다.
3. 왼쪽과 오른쪽 포크를 모두 집어들면 정해진 시간동안 식사를 한다.
4. 식사 시간이 끝나면 오른쪽 포크를 내려놓는다.
5. 오른쪽 포크를 내려놓은 뒤 왼쪽 포크를 내려놓는다.
6. 다시 1번부터 반복한다.

위 상황에서 철학자들이 동시에 식사를 하려고하면, 전부 생각만 하고 어떤 포크도 집어들지 못하거나 왼쪽 포크만 집어들어 실행을 못하는 상태를 **교착 상태**라고 한다.

교착 상태를 해결하기 위해서는 교착 상태가 발생했을 때의 상황을 정확히 표현할 수 있어야하고, 교착 상태가 일어나는 근본적인 이유를 이해해야한다.

먼저, 교착 상태가 발생했을 때의 상황을 정확히 확인하기 위해 **자원 할당 그래프**를 사용할 수 있다.
- 프로세스는 원, 자원은 사각형으로 표현한다.
- 사용할 수 있는 자원의 개수는 자원 사각형 내 점으로 표현한다.
- 프로세스가 어떤 자원을 할당 받아 사용 중이라면 자원에서 프로세스를 향해 화살표로 표시한다.
- 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표를 표시한다.

교착 상태가 일어나는 근본적인 이유를 이해하기 위해선 아래와 같은 조건을 보자. 아래 네 가지 조건을 모두 만족하면 교착 상태가 일어날 수 있다.
1. 상호 배제
2. 점유와 대기
3. 비선점
4. 원형 대기

### 교착 상태 해결 방법
교착 상태 해결 방법으로 크게 세 가지가 있다.
1. **예방**: 애초에 교착 상태가 발생하지 않도록 교착 상태 발생 조건 중 하나를 제거한다.
2. **회피**: 교착 상태를 무분별한 자원 할당으로 인해 발생했다고 간주하고, 교착 상태가 일어나지 않을만큼 자원의 양을 고려하여 배분하는 방법이다.
3. **검출 후 회복**: 교착 상태 발생을 인정하고, 사후에 조치를 취하는 방식이다.

#### 예방
- **상호 배제를 제거**: 모든 자원을 공유 가능하게 만드는건 비현실적인 방법이다.
- **점유와 대기를 제거**: 특정 프로세스에 자원을 몰빵하거나, 아예 할당하지 않는 방식으로 자원의 활용률이 낮다는 단점이 있다.
- **비선점을 제거**: CPU처럼 선점이 가능한 자원에 대해선 효과적일 수 있겠지만, 모든 자원이 선점할 수는 없어 범용성이 떨어진다.
- **원형 대기를 제거**: 자원에 번호를 붙이고 오름차순으로 할당하면 원형 대기는 발생하지 않는다. 하지만, 모든 자원에 번호를 붙이는 것이 단순한 작업은 아니고, 어떤 번호를 붙이느냐에 따라 활용률이 달라지는 단점이 있다.

#### 회피
- **안전 순서열**: 교착 상태 없이 프로세스들에 자원을 할당할 수 있는 순서
- **안전 상태**: 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태로 안전 순서열이 있는 상태로 볼 수 있다.
- **불완전 상태**: 교착 상태가 발생할 수도 있는 상태로 안전 순서열이 없는 상태로 볼 수 있다.

#### 검출 후 회복
- **선점을 통한 회복**: 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식이다.
- **프로세스 강제 종료를 통한 회복**: 교착 상태에 놓인 프로세스를 모두 강제 종료 시키거나, 교착 상태가 해결될 때까지 한 프로세스씩 강제 종료하는 방식이다. 전자는 작업 내용을 잃게 될 위험이 있고, 후자는 해결이 됐는지 계속 확인해야하므로 오버헤드가 발생할 수 있다.